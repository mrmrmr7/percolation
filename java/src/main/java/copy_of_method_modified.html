<?xml version="1.0" encoding="UTF-8"?>
<CopiedObjects modelType="MODEL">
    <CopyPasteInfo tag="copyPasteInfo">
        <!-- Keys to original paths -->
        <pathKeys T="0">/MethodCallFeatureList/methodcall1</pathKeys>
        <!-- Integer values of original paths -->
        <pathValues T="5">0</pathValues>
        <!-- Keys to reference settings -->
        <settingKeys T="0">/AppBuilderFeatureList/method1:methodcall.method</settingKeys>
        <!-- String values of reference settings -->
        <settingValues T="0">/AppBuilderFeatureList/method1</settingValues>
        <!-- Keys to serialization data -->
        <serializationKeys T="0">/methodCall/methodcall1</serializationKeys>
        <serializationKeys T="0">/applicationNodeList/method1</serializationKeys>
        <!-- String values of serialization data -->
        <serializationValues T="0"></serializationValues>
        <serializationValues T="0"></serializationValues>
        <!-- Copied in verision -->
        <copiedInVersion T="5">1261</copiedInVersion>
        <!-- Time stamp -->
        <timeStamp T="11">1578490259633</timeStamp>
        <CopiedPrimitiveObject tag="\AppBuilderFeatureList\method1">
            <!-- Type of copied object -->
            <type T="0">CodeEditor</type>
            <!-- Index -->
            <index T="5">1</index>
            <!-- Paste before index -->
            <pasteBeforeIndex T="5">0</pasteBeforeIndex>
        </CopiedPrimitiveObject>
    </CopyPasteInfo>
    <MethodCallFeature op="MethodCall" tag="methodcall1" name="Method1 1">
        <!-- Node status -->
        <entityFlags T="51">NODEACTIVATE</entityFlags>
        <!-- User comments -->
        <entityComments T="0"></entityComments>
        <!-- Created by -->
        <entityAuthor T="0"></entityAuthor>
        <!-- Creation time -->
        <entityCreationTime T="11">1572384645080</entityCreationTime>
        <!-- Dynamic property list -->
        <dynprop T="30" value="0.3" propName="p:p"></dynprop>
        <dynprop T="30" value="15" propName="p:N"></dynprop>
        <!-- Method -->
        <propertyValue T="30" value="/AppBuilderFeatureList/method1" name="p:methodcall.method"></propertyValue>
        <!-- #Toggle to indicate arguments changed -->
        <propertyValue T="30" value="on" name="p:methodcall.argschanged"></propertyValue>
        <MethodCallFeatureList tag="feature" name="Method Calls">
            <!-- User comments -->
            <entityComments T="0"></entityComments>
            <!-- Created by -->
            <entityAuthor T="0"></entityAuthor>
            <!-- Creation time -->
            <entityCreationTime T="11">1572384645081</entityCreationTime>
        </MethodCallFeatureList>
    </MethodCallFeature>
    <AppBuilderFeature op="CodeEditor" tag="method1" name="method1">
        <!-- Node status -->
        <entityFlags T="51">NODEACTIVATE</entityFlags>
        <!-- User comments -->
        <entityComments T="0"></entityComments>
        <!-- Created by -->
        <entityAuthor T="0"></entityAuthor>
        <!-- Creation time -->
        <entityCreationTime T="11">1572366003868</entityCreationTime>
        <!-- Last modification time -->
        <entityModifyTime T="11">1572389651372</entityModifyTime>
        <!-- Updated by -->
        <entityModifiedBy T="0"></entityModifiedBy>
        <!-- Feature status -->
        <status T="101">BUILT</status>
        <!-- Class byte code array -->
        <classByteCode T="24">{yv66vgAAADIAfQcAAgEAD2J1aWxkZXIvbWV0aG9kMQcABAEAIGNvbS9jb21zb2wvYXBpL0FwcGxpY2F0aW9uTWV0aG9kAQAGPGluaXQ+AQADKClWAQAEQ29kZQoAAwAJDAAFAAYBAA9MaW5lTnVtYmVyVGFibGUBAAdleGVjdXRlAQAWKERJKUxqYXZhL2xhbmcvU3RyaW5nOwkADgAQBwAPAQAgY29tL2NvbXNvbC9hcGkvTW9kZWxMYW5ndWFnZUJhc2UMABEAEgEABW1vZGVsAQAYTGNvbS9jb21zb2wvbW9kZWwvTW9kZWw7BwAUAQAiY29tL2NvbXNvbC9hcGkvSUFwcEludGVybmFsTWV0aG9kcwgAFgEAHi9BcHBCdWlsZGVyRmVhdHVyZUxpc3QvbWV0aG9kMQsAEwAYDAAZABoBAAlkZWJ1Z0hvb2sBABYoSUxqYXZhL2xhbmcvU3RyaW5nOylWBwAcAQAQamF2YS9sYW5nL1N0cmluZwoAHgAgBwAfAQAOamF2YS9sYW5nL01hdGgMACEAIgEABnJhbmRvbQEAAygpRAcAJAEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyCAAmAQAFcmVjX2kKACMAKAwABQApAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWCgABACsMACwALQEACHRvU3RyaW5nAQAVKEkpTGphdmEvbGFuZy9TdHJpbmc7CgAjAC8MADAAMQEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwgAMwEAAl9qCAA1AQACX2sKACMANwwALAA4AQAUKClMamF2YS9sYW5nL1N0cmluZzsIADoBAAVjb21wMgsAPAA+BwA9AQAWY29tL2NvbXNvbC9tb2RlbC9Nb2RlbAwAPwBAAQAJY29tcG9uZW50AQAwKExqYXZhL2xhbmcvU3RyaW5nOylMY29tL2NvbXNvbC9tb2RlbC9Nb2RlbE5vZGU7CABCAQAFZ2VvbTILAEQARgcARQEAGmNvbS9jb21zb2wvbW9kZWwvTW9kZWxOb2RlDABHAEgBAARnZW9tAQAzKExqYXZhL2xhbmcvU3RyaW5nOylMY29tL2NvbXNvbC9tb2RlbC9HZW9tU2VxdWVuY2U7CABKAQAFQmxvY2sLAEwATgcATQEAHWNvbS9jb21zb2wvbW9kZWwvR2VvbVNlcXVlbmNlDABPAFABAAZjcmVhdGUBAEQoTGphdmEvbGFuZy9TdHJpbmc7TGphdmEvbGFuZy9TdHJpbmc7KUxjb20vY29tc29sL21vZGVsL0dlb21GZWF0dXJlOwsATABSDABTAFQBAAdmZWF0dXJlAQAyKExqYXZhL2xhbmcvU3RyaW5nOylMY29tL2NvbXNvbC9tb2RlbC9HZW9tRmVhdHVyZTsIAFYBAANwb3MLAFgAWgcAWQEAHGNvbS9jb21zb2wvbW9kZWwvR2VvbUZlYXR1cmUMAFsAXAEAA3NldAEANChMamF2YS9sYW5nL1N0cmluZztbRClMY29tL2NvbXNvbC9tb2RlbC9Qcm9wRmVhdHVyZTsIAF4BAAVjb21wMQgAYAEABWdlb20xCwBMAGIMAGMABgEAA3J1bgEADVN0YWNrTWFwVGFibGUHAGYBABNbTGphdmEvbGFuZy9TdHJpbmc7AQAHbWV0aG9kMQgAZwcAagEAEGphdmEvbGFuZy9PYmplY3QKAGwAbgcAbQEAEGphdmEvbGFuZy9Eb3VibGUMAG8AcAEAB3ZhbHVlT2YBABUoRClMamF2YS9sYW5nL0RvdWJsZTsKAHIAdAcAcwEAEWphdmEvbGFuZy9JbnRlZ2VyDABvAHUBABYoSSlMamF2YS9sYW5nL0ludGVnZXI7CgABAHcMAHgAeQEACmNhbGxNZXRob2QBADkoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDsBAAdtZXRob2QyCAB6AQAKU291cmNlRmlsZQAhAAEAAwAAAAAABAABAAUABgABAAcAAAAdAAEAAQAAAAUqtwAIsQAAAAEACgAAAAYAAQAAAAgAAQALAAwAAQAHAAACeAAJAA4AAAHmsgANwAATEAoSFbkAFwMAsgANOgSyAA3AABMQCxIVuQAXAwABOgWyAA3AABMQDBIVuQAXAwAPOQayAA3AABMQDhIVuQAXAwAdHWgdaL0AGzoIsgANwAATEA8SFbkAFwMAAzYJsgANwAATEBASFbkAFwMAAzYKpwE1sgANwAATEBISFbkAFwMAAzYLpwEXsgANwAATEBQSFbkAFwMAAzYMpwD5sgANwAATEBUSFbkAFwMAuAAdJ5icAN+yAA3AABMQFhIVuQAXAwC7ACNZEiW3ACcVCrgAKrYALhIytgAuFQu4ACq2AC4SNLYALhUMuAAqtgAutgA2Og2yAA3AABMQFxIVuQAXAwAZCBUJGQ1TsgANwAATEBgSFbkAFwMAhAkBsgANwAATEBkSFbkAFwMAGQQSObkAOwIAEkG5AEMCABkNEkm5AEsDAFeyAA3AABMQGhIVuQAXAwAZBBI5uQA7AgASQbkAQwIAGQ25AFECABJVBrwHWQMVCocYBmtSWQQVC4cYBmtSWQUVDIcYBmtSuQBXAwBXhAwBFQwdof8HhAsBFQsdof7phAoBFQodof7LsgANwAATECISFbkAFwMAGQQSXbkAOwIAEl+5AEMCALkAYQEAsgANwAATECMSFbkAFwMAGQWwAAAAAgAKAAAATgATAAAACgAUAAsAJgAMADgADgBRAA8AYwAQAHgAEgCNABQAogAVALkAFgD4ABcBDgAYASAAGQFJABoBlQAUAZ4AEgGnABABsAAiAdQAIwBkAAAALAAH/wB4AAkHAAEDAQcAPAcAGwMHAGUBAQAA/AAUAfwAFAH7APIC+gAI+gAIAAQAZwAMAAEABwAAADMABgAEAAAAGxJoBb0AaVkDJ7gAa1NZBB24AHFTuAB2wAAbsAAAAAEACgAAAAYAAQAAACgABAB6AAYAAQAHAAAAIwACAAEAAAALEnsDvQBpuAB2V7EAAAABAAoAAAAGAAEAAAArAAEAfAAAAAIAZw==}</classByteCode>
        <!-- Class names -->
        <classNames T="1">1,'builder.method1'</classNames>
        <!-- Code -->
        <propertyValue T="30" value="package builder;&#xa;&#xa;import com.comsol.api.ApplicationMethod;&#xa;&#xa;import java.util.*;&#xa;&#xa;import static java.lang.Math.random;&#xa;&#xa;public class method1 extends ApplicationMethod {&#xa;&#xa;    public String execute(double p, int N) {&#xa;        String textlabel1 = null;&#xa;        {&#xa;            model.component().create(&quot;comp1&quot;, true);&#xa;            model.component(&quot;comp1&quot;).geom().create(&quot;geom1&quot;, 2);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).lengthUnit(&quot;km&quot;);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).scaleUnitValue(true);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).scaleUnitValue(false);&#xa;&#xa;            int size = 3;&#xa;            double probability = 0.6;&#xa;            int nucleus_size = 3;&#xa;            int shell_size = 1;&#xa;            double shell_probability = 0.5;&#xa;&#xa;            String SQUARE_NAME_STRING = &quot;sq:%d-%d&quot;;&#xa;&#xa;            boolean[][] grid = generate_2d_corn_cluster(size, probability);&#xa;&#xa;            boolean [][]grid2 = expand_existing_cluster_with_shell(&#xa;                    grid,&#xa;                    nucleus_size,&#xa;                    shell_size,&#xa;                    shell_probability&#xa;            );&#xa;&#xa;            int[][] grid3 = prepare_cluster_for_splitting(grid2);&#xa;&#xa;            int[][] grid4 = split_on_clusters(grid3);&#xa;            int[][] biggest_cluster_grid = retrieve_cluster_with_biggest_nucleus_count(grid4, size);&#xa;            for (int[] ints : grid4) {&#xa;                for (int each : ints) {&#xa;                    System.out.print(&quot;t&quot; + each);&#xa;                }&#xa;                System.out.println();&#xa;            }&#xa;            List&lt;String&gt; nameList = new ArrayList&lt;String&gt;();&#xa;&#xa;            for (int i = 0; i &lt; biggest_cluster_grid.length; i++) {&#xa;                for (int j = 0; j &lt; biggest_cluster_grid.length; j++) {&#xa;                    if (biggest_cluster_grid[i][j] &gt; 0) {&#xa;                        model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).create(&quot;sq:&quot; + i + &quot;-&quot; + j, &quot;Square&quot;);&#xa;                        model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).feature(String.format(SQUARE_NAME_STRING, i, j)).set(&quot;size&quot;, 1);&#xa;                        model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).feature(String.format(SQUARE_NAME_STRING, i, j)).set(&quot;pos&quot;, new double[]{i, j});&#xa;                        nameList.add(String.format(SQUARE_NAME_STRING, i, j));&#xa;                    }&#xa;                }&#xa;            }&#xa;&#xa;            String[] strAr = nameList.toArray(new String[nameList.size()]);&#xa;&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).create(&quot;uni1&quot;, &quot;Union&quot;);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).feature(&quot;uni1&quot;).set(&quot;intbnd&quot;, false);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).feature(&quot;uni1&quot;).selection(&quot;input&quot;).set(strAr);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).run();&#xa;        }&#xa;        return textlabel1;&#xa;    }&#xa;&#xa;    public boolean[][] generate_2d_corn_cluster(int size, double probability) {&#xa;        int N = size;&#xa;        double p = probability;&#xa;        int mid = N / 2;&#xa;&#xa;        Set&lt;int[]&gt; current_step_set = get_init_set(mid);&#xa;&#xa;        float[][] arr = new float[N][N];&#xa;        arr[mid][mid] = 1;&#xa;&#xa;        Set&lt;int[]&gt; next_step_set = current_step_set;&#xa;&#xa;        while (next_step_set.size() &gt; 0) {&#xa;            Set&lt;int[]&gt; next_set = new HashSet&lt;int[]&gt;();&#xa;&#xa;            for (int[] each : next_step_set) {&#xa;                if (random() &lt; p) {&#xa;                    arr[each[1]][each[0]] = 1;&#xa;                    if (each[1] != (N - 1)) {&#xa;                        if (arr[each[1] + 1][each[0]] == 0) {&#xa;                            int[] new_point = new int[]{each[0], each[1] + 1};&#xa;&#xa;                            boolean set_contains_point = false;&#xa;                            for (int[] point : next_set) {&#xa;                                if (point[0] == new_point[0]) {&#xa;                                    if (point[1] == new_point[1]) {&#xa;                                        set_contains_point = true;&#xa;                                        break;&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;                            if (!set_contains_point) {&#xa;                                next_set.add(new_point);&#xa;                            }&#xa;                        }&#xa;                    }&#xa;                    if (each[1] != 0) {&#xa;                        if (arr[each[1] - 1][each[0]] == 0) {&#xa;                            int[] new_point = new int[]{each[0], each[1] - 1};&#xa;&#xa;                            boolean set_contains_point = false;&#xa;                            for (int[] point : next_set) {&#xa;                                if (point[0] == new_point[0]) {&#xa;                                    if (point[1] == new_point[1]) {&#xa;                                        set_contains_point = true;&#xa;                                        break;&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;&#xa;                            if (!set_contains_point) {&#xa;                                next_set.add(new_point);&#xa;                            }&#xa;                        }&#xa;                    }&#xa;                    if (each[0] != (N - 1)) {&#xa;                        if (arr[each[1]][each[0] + 1] == 0) {&#xa;                            int[] new_point = new int[]{each[0] + 1, each[1]};&#xa;&#xa;                            boolean set_contains_point = false;&#xa;                            for (int[] point : next_set) {&#xa;                                if (point[0] == new_point[0]) {&#xa;                                    if (point[1] == new_point[1]) {&#xa;                                        set_contains_point = true;&#xa;                                        break;&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;                            if (!set_contains_point) {&#xa;                                next_set.add(new_point);&#xa;                            }&#xa;                        }&#xa;                    }&#xa;                    if (each[0] != 0) {&#xa;                        if (arr[each[1]][each[0] - 1] == 0) {&#xa;                            int[] new_point = new int[]{each[0] - 1, each[1]};&#xa;&#xa;                            boolean set_contains_point = false;&#xa;                            for (int[] point : next_set) {&#xa;                                if (point[0] == new_point[0]) {&#xa;                                    if (point[1] == new_point[1]) {&#xa;                                        set_contains_point = true;&#xa;                                        break;&#xa;                                    }&#xa;                                }&#xa;                            }&#xa;                            if (!set_contains_point) {&#xa;                                next_set.add(new_point);&#xa;                            }&#xa;                        }&#xa;                    }&#xa;                } else {&#xa;                    arr[each[1]][each[0]] = -1;&#xa;                }&#xa;            }&#xa;&#xa;            for (int[] each : next_step_set) {&#xa;                System.out.println(&quot;x: &quot; + each[0]);&#xa;                System.out.println(&quot;y: &quot; + each[1]);&#xa;                System.out.println();&#xa;            }&#xa;&#xa;            next_step_set = next_set;&#xa;        }&#xa;&#xa;        boolean[][] grid = new boolean[N][N];&#xa;&#xa;        for (int i = 0; i &lt; N; i++) {&#xa;            for (int j = 0; j &lt; N; j++) {&#xa;                grid[i][j] = arr[i][j] == 1;&#xa;            }&#xa;        }&#xa;&#xa;        return grid;&#xa;    }&#xa;&#xa;    Set&lt;int[]&gt; get_init_set(int mid) {&#xa;        Set&lt;int[]&gt; init_set = new HashSet&lt;int[]&gt;();&#xa;&#xa;        init_set.add(new int[]{mid + 1, mid});&#xa;        init_set.add(new int[]{mid - 1, mid});&#xa;        init_set.add(new int[]{mid, mid + 1});&#xa;        init_set.add(new int[]{mid, mid - 1});&#xa;&#xa;        return init_set;&#xa;    }&#xa;    public boolean[][] expand_existing_cluster_with_shell(boolean[][] grid, int nucleus_size, int shell_size, double shell_probability) {&#xa;        int scale = nucleus_size + shell_size + shell_size;&#xa;        int current_size = grid[0].length;&#xa;        int new_size = grid[0].length * scale;&#xa;        int center_bias = scale / 2;&#xa;        int nucleus_r = nucleus_size / 2;&#xa;&#xa;        boolean[][] new_grid = new boolean[new_size][new_size];&#xa;&#xa;        for (int i = 0; i &lt; current_size; i++) {&#xa;            for (int j = 0; j &lt; current_size; j++) {&#xa;                if (grid[i][j]) {&#xa;                    int left_shell_border = j * scale + center_bias - nucleus_r - shell_size;&#xa;                    int right_shell_border = j * scale + center_bias + nucleus_r + shell_size + 1;&#xa;                    int top_shell_border = i * scale + center_bias - nucleus_r;&#xa;                    int bot_shell_border = i * scale + center_bias + nucleus_r + 1;&#xa;&#xa;                    for (int k = i * scale + center_bias - nucleus_r; k &lt; i * scale + center_bias + nucleus_r + 1; k++) {&#xa;                        for (int n = j * scale + center_bias - nucleus_r; n &lt; j * scale + center_bias + nucleus_r + 1; n++) {&#xa;                            new_grid[k][n] = true;&#xa;                        }&#xa;                    }&#xa;&#xa;                    for (int n = 1; n &lt; shell_size + 1; n++) {&#xa;                        for (int k = left_shell_border; k &lt; right_shell_border; k++) {&#xa;                            if (Math.random() &gt; shell_probability) {&#xa;                                int top_border_row = i * scale + center_bias - nucleus_r - n;&#xa;                                new_grid[top_border_row][k] = true;&#xa;                            }&#xa;&#xa;                            if (Math.random() &gt; shell_probability) {&#xa;                                int bot_border_row = i * scale + center_bias + nucleus_r + n;&#xa;                                new_grid[bot_border_row][k] = true;&#xa;                            }&#xa;                        }&#xa;                    }&#xa;&#xa;&#xa;                    for (int n = 1; n &lt; shell_size + 1; n++) {&#xa;                        for (int k = top_shell_border; k &lt; bot_shell_border; k++) {&#xa;                            if (Math.random() &gt; shell_probability) {&#xa;                                int left_border_col = j * scale + center_bias - nucleus_r - n;&#xa;                                new_grid[k][left_border_col] = true;&#xa;                            }&#xa;                            if (Math.random() &gt; shell_probability) {&#xa;                                int right_border_col = j * scale + center_bias + nucleus_r + n;&#xa;                                new_grid[k][right_border_col] = true;&#xa;                            }&#xa;                        }&#xa;                    }&#xa;                }&#xa;            }&#xa;        }&#xa;&#xa;        return new_grid;&#xa;    }&#xa;&#xa;    public int[][] prepare_cluster_for_splitting(boolean[][] grid) {&#xa;        int[][] res = new int[grid[0].length][grid[0].length];&#xa;&#xa;        for (int i = 0; i &lt; grid[0].length; i++) {&#xa;            for (int j = 0; j &lt; grid[0].length; j++) {&#xa;                if (grid[i][j]) {&#xa;                    res[i][j] = -1;&#xa;                }&#xa;            }&#xa;        }&#xa;&#xa;        return res;&#xa;    }&#xa;&#xa;    public int[][] split_on_clusters(int[][] grid) {&#xa;        int grid_len = grid[0].length;&#xa;        int last_cluster_number = 1;&#xa;        Map&lt;Integer, List&lt;Integer[]&gt;&gt; cluster_dict = new HashMap&lt;Integer, List&lt;Integer[]&gt;&gt;();&#xa;&#xa;        for (int i = 0; i &lt; grid_len; i++) {&#xa;            for (int j = 0; j &lt; grid_len; j++) {&#xa;&#xa;                if (grid[i][j] == -1) {&#xa;                    boolean is_top_busy = false;&#xa;                    boolean is_left_busy = false;&#xa;&#xa;                    if (j &gt; 0) {&#xa;                        is_left_busy = grid[i][j - 1] &gt; 0;&#xa;                    }&#xa;&#xa;                    if (i &gt; 0) {&#xa;                        is_top_busy = grid[i - 1][j] &gt; 0;&#xa;                    }&#xa;&#xa;                    if (is_left_busy) {&#xa;                        if (is_top_busy) {&#xa;                            int top_val = grid[i - 1][j];&#xa;                            int left_val = grid[i][j - 1];&#xa;                            if (top_val != left_val) {&#xa;                                List&lt;Integer[]&gt; top_cluster = cluster_dict.get(top_val);&#xa;                                List&lt;Integer[]&gt; left_cluster = cluster_dict.get(left_val);&#xa;                                if (left_cluster.size() &gt; top_cluster.size()) {&#xa;                                    for (Integer[] each : top_cluster) {&#xa;                                        grid[each[0]][each[1]] = left_val;&#xa;                                        left_cluster.add(each);&#xa;                                    }&#xa;                                    cluster_dict.remove(top_val);&#xa;                                    left_cluster.add(new Integer[]{i, j});&#xa;                                    cluster_dict.put(left_val, left_cluster);&#xa;                                    grid[i][j] = left_val;&#xa;                                } else {&#xa;                                    for (Integer[] each : left_cluster) {&#xa;                                        grid[each[0]][each[1]] = top_val;&#xa;                                        top_cluster.add(each);&#xa;                                    }&#xa;                                    cluster_dict.remove(left_val);&#xa;&#xa;                                    top_cluster.add(new Integer[]{i, j});&#xa;                                    cluster_dict.put(top_val, top_cluster);&#xa;                                    grid[i][j] = top_val;&#xa;                                }&#xa;                            } else {&#xa;                                List&lt;Integer[]&gt; cluster = cluster_dict.get(grid[i][j - 1]);&#xa;                                cluster.add(new Integer[]{i, j});&#xa;                                cluster_dict.put(grid[i][j - 1], cluster);&#xa;                                grid[i][j] = grid[i][j - 1];&#xa;                            }&#xa;                        }&#xa;                    }&#xa;                    if (is_left_busy) {&#xa;                        if (!is_top_busy) {&#xa;                            grid[i][j] = grid[i][j - 1];&#xa;                            int val = grid[i][j];&#xa;                            List&lt;Integer[]&gt; cluster = cluster_dict.get(grid[i][j]);&#xa;                            cluster.add(new Integer[]{i, j});&#xa;                            cluster_dict.put(val, cluster);&#xa;                        }&#xa;                    }&#xa;                    if (is_top_busy) {&#xa;                        if (!is_left_busy) {&#xa;                            grid[i][j] = grid[i - 1][j];&#xa;                            int val = grid[i][j];&#xa;                            List&lt;Integer[]&gt; cluster = cluster_dict.get(grid[i][j]);&#xa;                            cluster.add(new Integer[]{i, j});&#xa;                            cluster_dict.put(val, cluster);&#xa;                        }&#xa;                    }&#xa;                    if (!is_left_busy) {&#xa;                        if (!is_top_busy) {&#xa;                            grid[i][j] = last_cluster_number;&#xa;                            List&lt;Integer[]&gt; new_cluster = new ArrayList&lt;Integer[]&gt;();&#xa;                            new_cluster.add(new Integer[]{i, j});&#xa;                            cluster_dict.put(grid[i][j], new_cluster);&#xa;                            last_cluster_number += 1;&#xa;                        }&#xa;                    }&#xa;                }&#xa;            }&#xa;        }&#xa;&#xa;        Set&lt;Integer&gt; kSet = cluster_dict.keySet();&#xa;        Integer[] keys = new Integer[kSet.size()];&#xa;        kSet.toArray(keys);&#xa;&#xa;        return grid;&#xa;    }&#xa;&#xa;    public int[][] retrieve_cluster_with_biggest_nucleus_count(int[][] grid, int core_count) {&#xa;        int core_with_shell_size = grid.length / core_count;&#xa;        int center_disp = (int)Math.floor(core_with_shell_size &gt;&gt; 1);&#xa;&#xa;        Map&lt;Integer, Integer&gt; coreCountList = new HashMap&lt;Integer, Integer&gt;();&#xa;        int x;&#xa;        int y;&#xa;        int knotVal;&#xa;&#xa;        for (int i = 0; i &lt; core_count; i++) {&#xa;            for (int j = 0; j &lt; core_count; j++) {&#xa;                x = j * core_with_shell_size + center_disp;&#xa;                y = i * core_with_shell_size + center_disp;&#xa;&#xa;                knotVal = grid[y][x];&#xa;                if (knotVal != 0) {&#xa;                    if (coreCountList.containsKey(knotVal)) {&#xa;                        coreCountList.replace(knotVal, coreCountList.get(knotVal) + 1);&#xa;                    } else {&#xa;                        coreCountList.put(knotVal, 1);&#xa;                    }&#xa;                }&#xa;            }&#xa;        }&#xa;&#xa;        int maxVal = 0;&#xa;&#xa;        for (Map.Entry&lt;Integer,Integer&gt; each : coreCountList.entrySet()) {&#xa;            if (each.getValue() &gt; maxVal) {&#xa;                maxVal = each.getValue();&#xa;            }&#xa;&#xa;            System.out.println(&quot;ttkey: &quot; + each.getKey() + &quot;ttvalue: &quot; + each.getValue());&#xa;        }&#xa;&#xa;        System.out.println(&quot;max val: &quot; + maxVal);&#xa;&#xa;        Set&lt;Integer&gt; maxValKeySet = new HashSet&lt;Integer&gt;();&#xa;&#xa;        for (Map.Entry&lt;Integer, Integer&gt; each : coreCountList.entrySet()) {&#xa;            if (each.getValue() == maxVal) {&#xa;                maxValKeySet.add(each.getKey());&#xa;            }&#xa;        }&#xa;&#xa;        Map&lt;Integer, Integer&gt; maxValPointsCount = new HashMap&lt;Integer, Integer&gt;();&#xa;        for (int each : maxValKeySet) {&#xa;            maxValPointsCount.put(each, 0);&#xa;        }&#xa;&#xa;        for (int i = 0; i &lt; grid.length; i++) {&#xa;            for (int j = 0; j &lt; grid.length; j++) {&#xa;                if (maxValPointsCount.containsKey(grid[i][j])) {&#xa;                    maxValPointsCount.replace(grid[i][j], maxValPointsCount.get(grid[i][j]) + 1);&#xa;                }&#xa;            }&#xa;        }&#xa;&#xa;        for (Map.Entry&lt;Integer,Integer&gt; each : maxValPointsCount.entrySet()) {&#xa;            System.out.println(&quot;ttmax key: &quot; + each.getKey() + &quot;ttcount: &quot; + each.getValue());&#xa;        }&#xa;&#xa;        int maxKey = 0;&#xa;        maxVal = 0;&#xa;&#xa;        for (Map.Entry&lt;Integer, Integer&gt; each : maxValPointsCount.entrySet()) {&#xa;            if (each.getValue() &gt; maxVal) {&#xa;                maxKey = each.getKey();&#xa;                maxVal = each.getValue();&#xa;            }&#xa;        }&#xa;&#xa;        for (int i = 0; i &lt; grid.length; i++) {&#xa;            for (int j = 0; j &lt; grid.length; j++) {&#xa;                if (grid[i][j] != maxKey) {&#xa;                    grid[i][j] = 0;&#xa;                }&#xa;            }&#xa;        }&#xa;&#xa;        return grid;&#xa;    }&#xa;}&#xa;" name="p:code"></propertyValue>
        <!-- #Byte code version -->
        <propertyValue T="30" value="5" name="p:compiledCodeVersion"></propertyValue>
        <!-- #Display interval start -->
        <propertyValue T="30" value="276" name="p:displayIntervalStart"></propertyValue>
        <!-- #Display interval end -->
        <propertyValue T="30" value="1214" name="p:displayIntervalEnd"></propertyValue>
        <!-- Name -->
        <propertyValue T="30" valueMatrix="1|2,'p','N'" name="p:inputNames"></propertyValue>
        <!-- Type -->
        <propertyValue T="30" valueMatrix="1|2,'real','integer'" name="p:inputTypes"></propertyValue>
        <!-- Default -->
        <propertyValue T="30" valueMatrix="1|2,'0.5','10'" name="p:inputDefaults"></propertyValue>
        <!-- Description -->
        <propertyValue T="30" valueMatrix="1|2,'',''" name="p:inputDescs"></propertyValue>
        <!-- Unit -->
        <propertyValue T="30" valueMatrix="1|2,'',''" name="p:inputUnits"></propertyValue>
        <!-- Output -->
        <propertyValue T="30" value="string" name="p:outputType"></propertyValue>
        <!-- Name -->
        <propertyValue T="30" value="textlabel1" name="p:outputName"></propertyValue>
        <NodeDefaultValues>5,'p:error','p:breakpoints','p:foldedRanges','p:showinmodelbuilder','p:inputsmoved'</NodeDefaultValues>
        <AppBuilderFeatureList tag="feature" name="AppBuilderFeatureList">
            <!-- User comments -->
            <entityComments T="0"></entityComments>
            <!-- Created by -->
            <entityAuthor T="0"></entityAuthor>
            <!-- Creation time -->
            <entityCreationTime T="11">1572366003923</entityCreationTime>
        </AppBuilderFeatureList>
    </AppBuilderFeature>
</CopiedObjects>

