<?xml version="1.0" encoding="UTF-8"?>
<CopiedObjects modelType="MODEL">
    <CopyPasteInfo tag="copyPasteInfo">
        <!-- Keys to original paths -->
        <pathKeys T="0">/MethodCallFeatureList/methodcall1</pathKeys>
        <!-- Integer values of original paths -->
        <pathValues T="5">0</pathValues>
        <!-- Keys to reference settings -->
        <settingKeys T="0">/AppBuilderFeatureList/method1:methodcall.method</settingKeys>
        <!-- String values of reference settings -->
        <settingValues T="0">/AppBuilderFeatureList/method1</settingValues>
        <!-- Keys to serialization data -->
        <serializationKeys T="0">/methodCall/methodcall1</serializationKeys>
        <serializationKeys T="0">/applicationNodeList/method1</serializationKeys>
        <!-- String values of serialization data -->
        <serializationValues T="0"></serializationValues>
        <serializationValues T="0"></serializationValues>
        <!-- Copied in verision -->
        <copiedInVersion T="5">1261</copiedInVersion>
        <!-- Time stamp -->
        <timeStamp T="11">1578349823949</timeStamp>
        <CopiedPrimitiveObject tag="\AppBuilderFeatureList\method1">
            <!-- Type of copied object -->
            <type T="0">CodeEditor</type>
            <!-- Index -->
            <index T="5">1</index>
            <!-- Paste before index -->
            <pasteBeforeIndex T="5">0</pasteBeforeIndex>
        </CopiedPrimitiveObject>
    </CopyPasteInfo>
    <MethodCallFeature op="MethodCall" tag="methodcall1" name="Method1 1">
        <!-- Node status -->
        <entityFlags T="51">NODEACTIVATE</entityFlags>
        <!-- User comments -->
        <entityComments T="0"></entityComments>
        <!-- Created by -->
        <entityAuthor T="0"></entityAuthor>
        <!-- Creation time -->
        <entityCreationTime T="11">1572384645080</entityCreationTime>
        <!-- Dynamic property list -->
        <dynprop T="30" value="0.3" propName="p:p"></dynprop>
        <dynprop T="30" value="15" propName="p:N"></dynprop>
        <!-- Method -->
        <propertyValue T="30" value="/AppBuilderFeatureList/method1" name="p:methodcall.method"></propertyValue>
        <!-- #Toggle to indicate arguments changed -->
        <propertyValue T="30" value="on" name="p:methodcall.argschanged"></propertyValue>
        <MethodCallFeatureList tag="feature" name="Method Calls">
            <!-- User comments -->
            <entityComments T="0"></entityComments>
            <!-- Created by -->
            <entityAuthor T="0"></entityAuthor>
            <!-- Creation time -->
            <entityCreationTime T="11">1572384645081</entityCreationTime>
        </MethodCallFeatureList>
    </MethodCallFeature>
    <AppBuilderFeature op="CodeEditor" tag="method1" name="method1">
        <!-- Node status -->
        <entityFlags T="51">NODEACTIVATE</entityFlags>
        <!-- User comments -->
        <entityComments T="0"></entityComments>
        <!-- Created by -->
        <entityAuthor T="0"></entityAuthor>
        <!-- Creation time -->
        <entityCreationTime T="11">1572366003868</entityCreationTime>
        <!-- Last modification time -->
        <entityModifyTime T="11">1572389651372</entityModifyTime>
        <!-- Updated by -->
        <entityModifiedBy T="0"></entityModifiedBy>
        <!-- Feature status -->
        <status T="101">BUILT</status>
        <!-- Class byte code array -->
        <classByteCode T="24">{yv66vgAAADIAfQcAAgEAD2J1aWxkZXIvbWV0aG9kMQcABAEAIGNvbS9jb21zb2wvYXBpL0FwcGxpY2F0aW9uTWV0aG9kAQAGPGluaXQ+AQADKClWAQAEQ29kZQoAAwAJDAAFAAYBAA9MaW5lTnVtYmVyVGFibGUBAAdleGVjdXRlAQAWKERJKUxqYXZhL2xhbmcvU3RyaW5nOwkADgAQBwAPAQAgY29tL2NvbXNvbC9hcGkvTW9kZWxMYW5ndWFnZUJhc2UMABEAEgEABW1vZGVsAQAYTGNvbS9jb21zb2wvbW9kZWwvTW9kZWw7BwAUAQAiY29tL2NvbXNvbC9hcGkvSUFwcEludGVybmFsTWV0aG9kcwgAFgEAHi9BcHBCdWlsZGVyRmVhdHVyZUxpc3QvbWV0aG9kMQsAEwAYDAAZABoBAAlkZWJ1Z0hvb2sBABYoSUxqYXZhL2xhbmcvU3RyaW5nOylWBwAcAQAQamF2YS9sYW5nL1N0cmluZwoAHgAgBwAfAQAOamF2YS9sYW5nL01hdGgMACEAIgEABnJhbmRvbQEAAygpRAcAJAEAF2phdmEvbGFuZy9TdHJpbmdCdWlsZGVyCAAmAQAFcmVjX2kKACMAKAwABQApAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWCgABACsMACwALQEACHRvU3RyaW5nAQAVKEkpTGphdmEvbGFuZy9TdHJpbmc7CgAjAC8MADAAMQEABmFwcGVuZAEALShMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9TdHJpbmdCdWlsZGVyOwgAMwEAAl9qCAA1AQACX2sKACMANwwALAA4AQAUKClMamF2YS9sYW5nL1N0cmluZzsIADoBAAVjb21wMgsAPAA+BwA9AQAWY29tL2NvbXNvbC9tb2RlbC9Nb2RlbAwAPwBAAQAJY29tcG9uZW50AQAwKExqYXZhL2xhbmcvU3RyaW5nOylMY29tL2NvbXNvbC9tb2RlbC9Nb2RlbE5vZGU7CABCAQAFZ2VvbTILAEQARgcARQEAGmNvbS9jb21zb2wvbW9kZWwvTW9kZWxOb2RlDABHAEgBAARnZW9tAQAzKExqYXZhL2xhbmcvU3RyaW5nOylMY29tL2NvbXNvbC9tb2RlbC9HZW9tU2VxdWVuY2U7CABKAQAFQmxvY2sLAEwATgcATQEAHWNvbS9jb21zb2wvbW9kZWwvR2VvbVNlcXVlbmNlDABPAFABAAZjcmVhdGUBAEQoTGphdmEvbGFuZy9TdHJpbmc7TGphdmEvbGFuZy9TdHJpbmc7KUxjb20vY29tc29sL21vZGVsL0dlb21GZWF0dXJlOwsATABSDABTAFQBAAdmZWF0dXJlAQAyKExqYXZhL2xhbmcvU3RyaW5nOylMY29tL2NvbXNvbC9tb2RlbC9HZW9tRmVhdHVyZTsIAFYBAANwb3MLAFgAWgcAWQEAHGNvbS9jb21zb2wvbW9kZWwvR2VvbUZlYXR1cmUMAFsAXAEAA3NldAEANChMamF2YS9sYW5nL1N0cmluZztbRClMY29tL2NvbXNvbC9tb2RlbC9Qcm9wRmVhdHVyZTsIAF4BAAVjb21wMQgAYAEABWdlb20xCwBMAGIMAGMABgEAA3J1bgEADVN0YWNrTWFwVGFibGUHAGYBABNbTGphdmEvbGFuZy9TdHJpbmc7AQAHbWV0aG9kMQgAZwcAagEAEGphdmEvbGFuZy9PYmplY3QKAGwAbgcAbQEAEGphdmEvbGFuZy9Eb3VibGUMAG8AcAEAB3ZhbHVlT2YBABUoRClMamF2YS9sYW5nL0RvdWJsZTsKAHIAdAcAcwEAEWphdmEvbGFuZy9JbnRlZ2VyDABvAHUBABYoSSlMamF2YS9sYW5nL0ludGVnZXI7CgABAHcMAHgAeQEACmNhbGxNZXRob2QBADkoTGphdmEvbGFuZy9TdHJpbmc7W0xqYXZhL2xhbmcvT2JqZWN0OylMamF2YS9sYW5nL09iamVjdDsBAAdtZXRob2QyCAB6AQAKU291cmNlRmlsZQAhAAEAAwAAAAAABAABAAUABgABAAcAAAAdAAEAAQAAAAUqtwAIsQAAAAEACgAAAAYAAQAAAAgAAQALAAwAAQAHAAACeAAJAA4AAAHmsgANwAATEAoSFbkAFwMAsgANOgSyAA3AABMQCxIVuQAXAwABOgWyAA3AABMQDBIVuQAXAwAPOQayAA3AABMQDhIVuQAXAwAdHWgdaL0AGzoIsgANwAATEA8SFbkAFwMAAzYJsgANwAATEBASFbkAFwMAAzYKpwE1sgANwAATEBISFbkAFwMAAzYLpwEXsgANwAATEBQSFbkAFwMAAzYMpwD5sgANwAATEBUSFbkAFwMAuAAdJ5icAN+yAA3AABMQFhIVuQAXAwC7ACNZEiW3ACcVCrgAKrYALhIytgAuFQu4ACq2AC4SNLYALhUMuAAqtgAutgA2Og2yAA3AABMQFxIVuQAXAwAZCBUJGQ1TsgANwAATEBgSFbkAFwMAhAkBsgANwAATEBkSFbkAFwMAGQQSObkAOwIAEkG5AEMCABkNEkm5AEsDAFeyAA3AABMQGhIVuQAXAwAZBBI5uQA7AgASQbkAQwIAGQ25AFECABJVBrwHWQMVCocYBmtSWQQVC4cYBmtSWQUVDIcYBmtSuQBXAwBXhAwBFQwdof8HhAsBFQsdof7phAoBFQodof7LsgANwAATECISFbkAFwMAGQQSXbkAOwIAEl+5AEMCALkAYQEAsgANwAATECMSFbkAFwMAGQWwAAAAAgAKAAAATgATAAAACgAUAAsAJgAMADgADgBRAA8AYwAQAHgAEgCNABQAogAVALkAFgD4ABcBDgAYASAAGQFJABoBlQAUAZ4AEgGnABABsAAiAdQAIwBkAAAALAAH/wB4AAkHAAEDAQcAPAcAGwMHAGUBAQAA/AAUAfwAFAH7APIC+gAI+gAIAAQAZwAMAAEABwAAADMABgAEAAAAGxJoBb0AaVkDJ7gAa1NZBB24AHFTuAB2wAAbsAAAAAEACgAAAAYAAQAAACgABAB6AAYAAQAHAAAAIwACAAEAAAALEnsDvQBpuAB2V7EAAAABAAoAAAAGAAEAAAArAAEAfAAAAAIAZw==}</classByteCode>
        <!-- Class names -->
        <classNames T="1">1,'builder.method1'</classNames>
        <!-- Code -->
        <propertyValue T="30" value="package builder;&#xa;&#xa;import com.comsol.api.ApplicationMethod;&#xa;&#xa;import java.util.ArrayList;&#xa;import java.util.HashSet;&#xa;import java.util.List;&#xa;import java.util.Set;&#xa;&#xa;import static java.lang.Math.random;&#xa;&#xa;public class method1 extends ApplicationMethod {&#xa;&#xa;    public String execute(double p, int N) {&#xa;        String textlabel1 = null;&#xa;        {&#xa;&#xa;&#xa;            model.component().remove(&quot;comp1&quot;);&#xa;&#xa;            model.component().create(&quot;comp1&quot;, true);&#xa;            model.component(&quot;comp1&quot;).geom().create(&quot;geom1&quot;, 2);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).lengthUnit(&quot;km&quot;);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).scaleUnitValue(true);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).scaleUnitValue(false);&#xa;&#xa;            String SQUARE_NAME_STRING = &quot;sq:%d-%d&quot;;&#xa;&#xa;            int mid = N / 2;&#xa;&#xa;            Set&lt;int[]&gt; current_step_set = new HashSet&lt;int[]&gt;();&#xa;&#xa;            current_step_set.add(new int[]{mid + 1, mid});&#xa;            current_step_set.add(new int[]{mid - 1, mid});&#xa;            current_step_set.add(new int[]{mid, mid + 1});&#xa;            current_step_set.add(new int[]{mid, mid - 1});&#xa;&#xa;            float[][] arr = new float[N][N];&#xa;            arr[mid][mid] = 1;&#xa;&#xa;            Set&lt;int[]&gt; next_step_set = current_step_set;&#xa;&#xa;            while (next_step_set.size() &gt; 0) {&#xa;                Set&lt;int[]&gt; next_set = new HashSet&lt;int[]&gt;();&#xa;&#xa;                for (int[] each : next_step_set) {&#xa;                    if (random() &lt; p) {&#xa;                        arr[each[1]][each[0]] = 1;&#xa;                        if (each[1] != (N - 1)) {&#xa;                            if (arr[each[1] + 1][each[0]] == 0) {&#xa;                                int[] new_point = new int[]{each[0], each[1] + 1};&#xa;&#xa;                                boolean set_contains_point = false;&#xa;                                for (int[] point : next_set) {&#xa;                                    if (point[0] == new_point[0]) {&#xa;                                        if (point[1] == new_point[1]) {&#xa;                                            set_contains_point = true;&#xa;                                            break;&#xa;                                        }&#xa;                                    }&#xa;                                }&#xa;                                if (!set_contains_point) {&#xa;                                    next_set.add(new_point);&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                        if (each[1] != 0) {&#xa;                            if (arr[each[1] - 1][each[0]] == 0) {&#xa;                                int[] new_point = new int[]{each[0], each[1] - 1};&#xa;&#xa;                                boolean set_contains_point = false;&#xa;                                for (int[] point : next_set) {&#xa;                                    if (point[0] == new_point[0]) {&#xa;                                        if (point[1] == new_point[1]) {&#xa;                                            set_contains_point = true;&#xa;                                            break;&#xa;                                        }&#xa;                                    }&#xa;                                }&#xa;&#xa;                                if (!set_contains_point) {&#xa;                                    next_set.add(new_point);&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                        if (each[0] != (N - 1)) {&#xa;                            if (arr[each[1]][each[0] + 1] == 0) {&#xa;                                int[] new_point = new int[]{each[0] + 1, each[1]};&#xa;&#xa;                                boolean set_contains_point = false;&#xa;                                for (int[] point : next_set) {&#xa;                                    if (point[0] == new_point[0]) {&#xa;                                        if (point[1] == new_point[1]) {&#xa;                                            set_contains_point = true;&#xa;                                            break;&#xa;                                        }&#xa;                                    }&#xa;                                }&#xa;                                if (!set_contains_point) {&#xa;                                    next_set.add(new_point);&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                        if (each[0] != 0) {&#xa;                            if (arr[each[1]][each[0] - 1] == 0) {&#xa;                                int[] new_point = new int[]{each[0] - 1, each[1]};&#xa;&#xa;                                boolean set_contains_point = false;&#xa;                                for (int[] point : next_set) {&#xa;                                    if (point[0] == new_point[0]) {&#xa;                                        if (point[1] == new_point[1]) {&#xa;                                            set_contains_point = true;&#xa;                                            break;&#xa;                                        }&#xa;                                    }&#xa;                                }&#xa;                                if (!set_contains_point) {&#xa;                                    next_set.add(new_point);&#xa;                                }&#xa;                            }&#xa;                        }&#xa;                    } else {&#xa;                        arr[each[1]][each[0]] = -1;&#xa;                    }&#xa;                }&#xa;&#xa;                for (int[] each : next_step_set) {&#xa;                    System.out.println(&quot;x: &quot; + each[0]);&#xa;                    System.out.println(&quot;y: &quot; + each[1]);&#xa;                    System.out.println();&#xa;                }&#xa;&#xa;                next_step_set = next_set;&#xa;            }&#xa;&#xa;            boolean[][] grid = new boolean[N][N];&#xa;&#xa;            for (int i = 0; i &lt; N; i++) {&#xa;                for (int j = 0; j &lt; N; j++) {&#xa;                    grid[i][j] = arr[i][j] == 1;&#xa;                }&#xa;            }&#xa;&#xa;            List&lt;String&gt; nameList = new ArrayList&lt;String&gt;();&#xa;&#xa;            for (int i = 0; i &lt; N; i++) {&#xa;                for (int j = 0; j &lt; N; j++) {&#xa;                    if (grid[i][j]) {&#xa;                        model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).create(&quot;sq:&quot; + i + &quot;-&quot; + j, &quot;Square&quot;);&#xa;                        model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).feature(String.format(SQUARE_NAME_STRING, i, j)).set(&quot;size&quot;, 1);&#xa;                        model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).feature(String.format(SQUARE_NAME_STRING, i, j)).set(&quot;pos&quot;, new double[]{i, j});&#xa;                        nameList.add(String.format(SQUARE_NAME_STRING, i, j));&#xa;                    }&#xa;                }&#xa;            }&#xa;&#xa;            String[] strAr = nameList.toArray(new String[nameList.size()]);&#xa;&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).create(&quot;uni1&quot;, &quot;Union&quot;);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).feature(&quot;uni1&quot;).set(&quot;intbnd&quot;, false);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).feature(&quot;uni1&quot;).selection(&quot;input&quot;).set(strAr);&#xa;            model.component(&quot;comp1&quot;).geom(&quot;geom1&quot;).run();&#xa;        }&#xa;        return textlabel1;&#xa;    }&#xa;&#xa;}&#xa;" name="p:code"></propertyValue>
        <!-- #Byte code version -->
        <propertyValue T="30" value="5" name="p:compiledCodeVersion"></propertyValue>
        <!-- #Display interval start -->
        <propertyValue T="30" value="276" name="p:displayIntervalStart"></propertyValue>
        <!-- #Display interval end -->
        <propertyValue T="30" value="1214" name="p:displayIntervalEnd"></propertyValue>
        <!-- Name -->
        <propertyValue T="30" valueMatrix="1|2,'p','N'" name="p:inputNames"></propertyValue>
        <!-- Type -->
        <propertyValue T="30" valueMatrix="1|2,'real','integer'" name="p:inputTypes"></propertyValue>
        <!-- Default -->
        <propertyValue T="30" valueMatrix="1|2,'0.5','10'" name="p:inputDefaults"></propertyValue>
        <!-- Description -->
        <propertyValue T="30" valueMatrix="1|2,'',''" name="p:inputDescs"></propertyValue>
        <!-- Unit -->
        <propertyValue T="30" valueMatrix="1|2,'',''" name="p:inputUnits"></propertyValue>
        <!-- Output -->
        <propertyValue T="30" value="string" name="p:outputType"></propertyValue>
        <!-- Name -->
        <propertyValue T="30" value="textlabel1" name="p:outputName"></propertyValue>
        <NodeDefaultValues>5,'p:error','p:breakpoints','p:foldedRanges','p:showinmodelbuilder','p:inputsmoved'</NodeDefaultValues>
        <AppBuilderFeatureList tag="feature" name="AppBuilderFeatureList">
            <!-- User comments -->
            <entityComments T="0"></entityComments>
            <!-- Created by -->
            <entityAuthor T="0"></entityAuthor>
            <!-- Creation time -->
            <entityCreationTime T="11">1572366003923</entityCreationTime>
        </AppBuilderFeatureList>
    </AppBuilderFeature>
</CopiedObjects>

